---
title: "Runapp talk"
author: "James Goldie"
format:
  revealjs: 
    theme: [default, style.scss]
    width: 1400
    css:
      - https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.2/font/bootstrap-icons.css
---

## Today {style="text-align: center;"}

:::: {.columns}
::: {.column width="50%"}
1. **Who I am**
  - My background
2. **What are reproducible reports?**
  - R Markdown
  - Notebooks (eg. Jupyter)
  - Survey time!
3. **What's Quarto?**
  - How it works
4. **Advantage A: it brings the ecosystem together**
  - Languages
  - RMarkdown extensions
  - Future ecosystem? Extensibility?
:::
::: {.column width="50%"}
5. **Advantage B: reactivity**
  - Problem: Having things change as you read (not just when I render)
  - The crappy way: event listeners
  - Existing models of reactivity: Shiny and Dash
    - Downside: need a server running!
  - Quarto and Observable
:::
::::

# I'm James {.text-wash-black background="aquamarine"}

## {.text-wash-seafoam}

::: {.notes}
Blah
:::

::::: {.columns style="text-align:center;margin-top:50px;"}

:::: {.column width="50%" style="margin-top:50px"}
::: {.r-stack}
![](images/gradloopinf.gif){.fragment .fade-in-then-semi-out fragment-index=1 style="width:70%;transform:rotate(-5deg);" fig-alt="A picture of me and my PhD supervisor, Lisa Alexander, at my graduation."}

![](images/mcccrh-zoom.png){.fragment .fade-in-then-semi-out fragment-index=2 style="transform:rotate(5deg);" fig-alt="A picture of me and MCCCRH staff members on Zoom."}

![](images/mcccrh.gif){.fragment .fade-in-then-semi-out fragment-index=3 style="transform:rotate(-1deg);" fig-alt="A picture of me and MCCCRH staff members on a work trip."}

![](images/mcccrh-projections.jpg){.fragment .fade-in-then-semi-out fragment-index=4 style="transform:rotate(1.5deg); fig-alt="A picture of Graham Creed from the ABC presenting climate projections."}

![](images/mcccrh-7news.gif){.fragment .fade-in-then-semi-out fragment-index=5 style="transform:rotate(-3.5deg);" fig-alt="A picture of Jane Bunn presenting statistics on shrinking winters."}

![](images/360logo.png){.fragment fragment-index=6 style="width:85%" fig-alt="The 360info logo."}
:::
::::

:::: {.column width="50%"  style="margin-top:25px"}
::: {.fragment fragment-index=1}
I used to be a climate + health researcher 
:::
::: {.fragment fragment-index=2}
â€¢

Worked with **[CLEX](https://climateextremes.org.au)** and **[MCCCRH](https://monash.edu/mcccrh)** on climate change communication
:::
::: {.fragment fragment-index=6}
â€¢

Now a data journalist with **[360info.org](https://360info.org)!**
:::
::::

:::::

## Poll: what tools do you use? {.text-wash-seafoam style="text-align: center;"}

:::: {.columns}
:::{.column width="40%"}
![](./images/qrcode-survey.png){style="filter:invert(1)" fig-alt="A QR code for the survey."}
:::

::: {.column width="60%" .center}
<br>Take the survey at **<https://forms.gle/GtszJpXZYjppsQAz8>**
:::
::::

## {.text-wash-seafoam style="text-align: center;"}

```{ojs}
md`## Poll results (Respondents: ${respondentCount})`
```

```{ojs}

import { liveGoogleSheet } from "@jimjamslam/live-google-sheet";
import { aq, op } from "@uwdata/arquero";

surveyResults = liveGoogleSheet(
  "https://docs.google.com/spreadsheets/d/e/" +
    "2PACX-1vSVQzZlkSWWR38FRKyFbO2WGYo04ehrJt4TvWkRVOJ7WPRmfQzPAf7AjtyV2EjIY-2DwKW-SfzLoEQw/" +
    "pub?gid=1368316628&single=true&output=csv",
  30000, 1, 2);

respondentCount = surveyResults.length;
```

```{ojs}
// get the counts of people using and interested in tools
countsUsed = aq.from(surveyResults)
  .derive({ used: d => op.split(d.responseUsed, ", ") })
  .select("used")
  .unroll("used")
  .groupby("used")
  .count()
  .derive({ measure: d => "Have used" })
  .rename({ used: "tool" })
```

```{ojs}
countsWant = aq.from(surveyResults)
  .derive({ want: d => op.split(d.responseWant, ", ") })
  .select("want")
  .unroll("want")
  .groupby("want")
  .count()
  .derive({ measure: d => "Want to learn" })
  .rename({ want: "tool" })
```

```{ojs}
// combine the two counts into one dataset again
countsAll = [...countsUsed.objects(), ...countsWant.objects()];

plotUsed = Plot.plot({
  marks: [
    Plot.barX(countsAll, { y: "tool", x: "count", fill: "tool" }),
    Plot.ruleX([respondentCount])
  ],
  x : { label: "" },
  y : { label: "", tickSize: 0 },
  facet: { data: countsAll, x: "measure", label: "" },
  marginLeft: 140,
  style: {
    backgroundColor: "black",
    color: "white",
    width: 1350,
    height: 500,
    fontSize: 12,
  }
});
```

<!-- keep a qr code up in the top-right corner -->
![](./images/qrcode-survey.png){style="filter:invert(1);position:fixed;top:0;right:0;" fig-alt="A picture of a QR code to the survey."}

# What are <br>[reproducible reports?]{.hl .hl-gold} {.text-wash-black background="goldenrod"}

## {background-image="images/confused-dog.jpg"}

::: {.notes}
If you work in Python or Julia, you may have heard of **notebooks**

R users might have heard of **reproducible reports**

All examples of **literate programming**

Literate programming is about _explaining your code_ by combining code with written prose and graphics
:::

##

::: {.notes}
Very nice to read!

Readable even if you didn't write it

File format is opaque and hard to version control

Files shared or hosted on special notebook services
:::

:::: {.columns}
::: {.column width="50%" style="margin-top:30px;"}
<h2 class="text-wash-yellow">Notebooks</h2>

* Contain:
  - Writing
  - Code
  - <span style="color:gold;">**Results in the file too**</span>

:::
::: {.column width="50%"}

![](images/notebook.png){fig-alt="A picture of a Jupyter notebook loaded into Visual Studio Code."}
:::
::::

## Reproducible reports {.text-wash-yellow style="text-align:center"}

Source **documents** are **rendered** to produce **results**

::: {.notes}
R Markdown is more common among R users

Instead of code and results together, we _render_ a source document

Contains writing and code, but not results!

An R Markdown document is _rendered_. The final report is a separate file!

Plain text source file

Easy to see changes over time in version control

Docs, books, websites, presentations...

Need R to run it
:::

:::: {.columns}
::: {.column width="50%"}
![](images/rmd-source.png){fig-alt="An R Markdown source document in a plain text code editor"}
:::
<!-- ::: {.column width="20%"}
 
::: -->
::: {.column width="50%"}
![](images/rmd-render.png){fig-alt="An R Markdown document rendered into HTML with a plot in it."}
:::
::::

## The RMarkdown ecosystem {.text-wash-yellow}

::: {.notes}
Because R Markdown gets rendered, it can make lots of different kinds of documents!
:::

::: {style="text-align:center;margin-top:175px;"}

R packages for just about every kind of document:

[`xaringan`](https://github.com/yihui/xaringan) â€¢ [`distill`](https://rstudio.github.io/distill) â€¢ [`blogdown`](https://bookdown.org/yihui/blogdown) â€¢ [`hugodown`](https://github.com/r-lib/hugodown) â€¢ [`bookdown`](https://bookdown.org) â€¢ [`thesisdown`](https://github.com/ismayc/thesisdown) â€¢ [`oxforddown`](https://ulyngs.github.io/oxforddown) â€¢ [`unswthesisdown`](https://github.com/jimjam-slam/unswthesisdown) â€¢ [`pagedown`](https://github.com/rstudio/pagedown) â€¢ [`flexdashboard`](https://pkgs.rstudio.com/flexdashboard/) â€¢ [`rmdformats`](https://github.com/juba/rmdformats) â€¢ [`rticles`](https://github.com/rstudio/rticles) â€¢ [`prettydoc`](https://prettydoc.statr.me/) â€¢ [`markdowntemplates`](https://github.com/hrbrmstr/markdowntemplates) â€¢ and more...
:::

# Quarto:<br>[Literate programming for[everyone]{.hl .hl-purple}]{style="font-size:75%;"} { background="#7609e3"}

::: {.notes}
So we have two very different approaches to explaining your data.

Notebooks are a really nice writing experience, and it's good to have code and results in one place.

But they're difficult to share or collaborate on without dedicated services.

RMarkdown docs have a massive ecosystem for lots of different outputs, and they're very clear and easy to share. But not everyone uses R!

Quarto tries to have its cake and eat it too.
:::

## Notebooks or documents: your choice {.text-wash-indigo background="white" style="text-align:center"}

::: {.notes}
You don't have to choose between writing in notebooks or documents - they both work!

Here we have a Quarto report, written two different ways: a notebook and a document.

Either of these can be rendered - into a webpage, a blog post, a slideshow, a Word document, a PDF...

If you're used to documents, Quarto ones look almost the same!

We still have _chunk options_ (cell options for notebook people). They sit as special comments at the start of the cell, and they're written in YAML. You can add them to notebook cells too!

(The old RMarkdown way still works.)

Frontmatter still works largely the same as RMarkdown, but you can add it to notebooks too!
:::

![](images/notebook-vs-document.png){fig-alt="A picture of the same Quarto document side-by-side, written in notebook form on the left and document form on the right." style="width:100%; height:auto;"}

## R, Python, Julia: your choice {.text-wash-indigo background="white" style="text-align:center"}

::: {.notes}
The other big change here is that you can use your **favourite language** in **either format.**

You can write Python chunks in a document like the one on the right, and you can render it **without needing to have R installed.**

On the flip side, you can write R cells in a notebook. Or Julia. **Or all three!**

Quarto is a **separate tool** that runs in the shell. It comes with everything you need, except the programming languages you want to use.
:::

![](images/notebook-vs-document.png){fig-alt="A picture of the same Quarto document side-by-side, written in notebook form on the left and document form on the right." style="width:100%; height:auto;"}

## Your choice of editor {.text-wash-indigo background="white" style="text-align: center"}

::: {.notes}
The examples I've shown are in Visual Studio Code, which is a code editor that I love.

Quarto works really nicely there. It even has a help panel that switches languages as you type!

Quarto also works fantastically with the JupyterLab editor and with RStudio.
:::

:::: {.columns style="margin-top:150px;"}
::: {.column width="33%"}
[![](images/editor-vscode.png){fig-alt="Visual Studio Code logo" width="250px"}](https://code.visualstudio.com)
:::
::: {.column width="33%"}
[![](images/editor-rstudio.png){fig-alt="RStudio logo" width="250px"}](https://rstudio.com)
:::
::: {.column width="33%"}
[![](images/editor-jupyterlab.png){fig-alt="Jupyter logo" width="250px"}](https://jupyterlab.readthedocs.io/en/stable)
:::
::::

## RStudio visual editor {.text-wash-indigo background="white" style="text-align: center"}

::: {.notes}
If you use RStudio and you're used to writing documents but like the way notebooks look, you don't even have to choose!

RStudio has a **notebook-style editor** _for documents_.

You can switch back and forth as you like, and it has a command palette to help you insert things.
:::

:::: {.columns}
::: {.column width="50%"}
![](images/rstudio-source.png){fig-alt="Editing a Quarto document in RStudio in the plain text view."}
:::
::: {.column width="50%"}
![](images/rstudio-visual.png){fig-alt="Editing a Quarto document in RStudio in the visual editor"}"}
:::
::::

## (point about cross-tech) {.text-wash-indigo background="white" style="text-align: center"}

::: {.notes}
R Markdown has been able to include code from other languages for a while, but I think this is a really big step to facilitating cross-language collaboration.

For someone who only works in Python or Julia, it's a really tough sell to ask them to install R and several packages in order to write documents.

With Quarto, you can have a website with people contributing posts as a mix of notebooks and documents in any (or all languages).
:::

(slide content here)

# Spicing up Quarto<br>[with [reactivity]{.hl .hl-red} and [Observable JS]{.hl .hl-red}]{style="font-size:75%;"} { background="#e31a1c"}

::: {.notes}

:::

##

::: {.notes}
(notes here)
:::

::: {style="margin-top:-100px"}
### Reactivity? {.r-fit-text .text-wash-orange}

### HUH? {.r-fit-text .text-wash-red style="font-weight:900"}
:::

## Reactivity is... {.text-wash-red}

::: {.notes}
So when we render our document, code runs and it changes how the report looks.

Maybe it creates a plot from some data, or prints some statistics.

But sometimes we want the document change **as it's being read.**
:::

## Code is usually about [doing things]{.hl .hl-red} {.text-wash-red .center style="text-align:center"} 

::: {.notes}
Programs and websites do this all the time! There's a user interface with buttons and dials and sliders, and when we play with them, stuff happens.

But making that happen can be really tiring.

Web and app developers deal with this all the time:

* write code to create the button
* then write code to check its value all the time
* then write code to do things every time it changes

That's powerful, but it gets old really quickly!
:::

::::: {.columns}

:::: {.column width="50%"}
::: {.incremental}
* Write code to **create a control**
* Write code to **check its value all the time**
* Write code to **do things every time it changes**
* Write code to **pass updates from one thing to another**
:::
::::

:::: {.column width="50%"}
::: {.fragment}

<h2 class="text-wash-orange">This gets old quickly!</h2>

### ðŸ˜© {style="font-size:600%"}

:::
::::

:::::

## Reactive code just updates itself {.text-wash-red .center style="text-align:center"}

::: {.fragment}
Describe a control or input 
:::

::: {.fragment}
Describe an output that **reacts** to the control's changes
:::
 
::: {.fragment}
... there is no step 3

<span style="font-size:smaller">(the output takes care of itself!)</span>
:::

## Example: footy scores {.text-wash-red style="text-align:center" background="white"}

Example: **menu** + **slider** => **chart of footy scores**

```{ojs}
//| echo: false
// scores = await aq.loadCSV("data/footy-scores.csv")
scores = FileAttachment("data/footy-scores.csv").csv({ typed: true })

viewof footyTeam = Inputs.select(
  ["Pies", "Blues", "Bombers", "Cats"],
  { value: "Blues", label: "Footy team" })

viewof year = Inputs.range([1990, 2005], { value: 1990, label: "Year" })

filteredScores = scores.filter(d => d.team == footyTeam && d.year == year)

Plot.plot({
  marks: [
    Plot.barY(filteredScores, { x: "game", y: "score" }),
    Plot.ruleY(0)
  ],
  x: { label: "Game number" },
  y: { label: "Score" }
})
```

## This is how [Shiny]{.hl .hl-red} and [Dash]{.hl .hl-red} work! {.text-wash-red style="text-align:center"}


::::: {.columns}

:::: {.column width="50%"}
::: {.fragment}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "|6,11,13"

# describe some controls - a dropdown menu
# and a slider - and a plot

ui <- fluidPage(

  selectInput("footyTeam",
    label = "Footy team",
    choices = c("Pies", "Blues",
      "Bombers", "Cats"),
    selected = "Blues"),
  sliderInput("year", label = "Year",
    1990, 2005, value = 1991),
  plotOutput("footyScores")
  
)
```
:::
::::
:::: {.column width="50%"}
::: {.fragment}
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "|8,9,10"
# for the plot, filter our data and
# draw a line chart

server <- function(input, out) {
  output$footyScores <- renderPlot({

    scores %>%
    filter(
      year == input$year,
      house == input$footyTeam) %>%
    {
      ggplot(.) +
        aes(x = game, y = score) +
        geom_line()
    }
    
  })}
```
:::
::::
:::::

## This is how [Shiny]{.hl .hl-red} and [Dash]{.hl .hl-red} work! {.text-wash-red style="text-align:center"}

Shiny already works with R Markdown, and it works with Quarto too
